
import os, sys
import pipeline_scripts.utils as utils
import pathlib
from scipy import ndimage
import cv2 as cv
from shapely import geometry as geo
from shapely.ops import unary_union
import numpy as np
import matplotlib.pyplot as plt
from shapely.ops import polygonize
from shapely.validation import make_valid
from shapely.geometry.polygon import Polygon
from shapely.geometry.multipolygon import MultiPolygon

import math
from matplotlib.patches import Rectangle

global Suturing_Needle_out_of_Tissue
global Suturing_Needle_Right_of_Tissue
global x_center_last,y_center_last
global LG_dist_N_last,RG_dist_N_last
global LG_inter_N_last,RG_inter_N_last
global bi_x_last, n_x_last
LG_dist_N_last,RG_dist_N_last = 0,0
x_center_last,y_center_last = 0,0
LG_inter_N_last,RG_inter_N_last = 0,0
bi_x_last, n_x_last =0,0
global closestRingCenterX_last,closestRingCenterY_last
closestRingCenterX_last,closestRingCenterY_last = 0,0
Suturing_Needle_Right_of_Tissue = True
Suturing_Needle_out_of_Tissue = False

class Context_Iterator:

    def __init__(self,MASK_SET, TASK,TRIAL, CDW):
        self.CWD = CDW   
        self.task = TASK
        self.imagesDir = os.path.join(self.CWD, "data", "images", TRIAL)
        self.imagePredDir = os.path.join(self.CWD, "eval", "labeled_images",MASK_SET,TRIAL)
        self.cogitoDir = os.path.join(self.CWD, "data", "cogito_annotations")    
        #self.deeplabOutputDir= os.path.join(self.CWD,task,"2023_labeled_images_test")     
        self.ctxConsensusDir = os.path.join(self.CWD,"data","context_labels","consensus")
        self.ctxSurgeonDir = os.path.join(self.CWD,"data","context_labels","surgeon")
        self.ctxPredDir =  os.path.join(self.CWD,"eval","pred_context_labels",MASK_SET)
        self.tissueDir =  os.path.join(self.CWD,"data","tissue_keypoints") # contains VIA labels for the points on the canvas (Suturing)
        self.grasperJawDir = os.path.join(self.CWD,"data","grasper_jaw_keypoints") # contains VIA labels for the grasper jaw points
        self.contourDir =  os.path.join(self.CWD,"data","contours",MASK_SET) # All of the contour points generated by contours.py
        self.mask_dir = os.path.join(self.CWD,"data","masks",MASK_SET)
        self.OS = "windows" 

    # we want the dictionary for only one Trial
    def getTissueData(self,trial,TestMode=False,MatchLines=0):
        #print("Starting:getTissueData ->")
        Tissues, TissueFrames = {}, {}
        file = os.path.join(self.tissueDir,trial+".json")
        if not os.path.isfile(file): return {},{}
        #if "frame" not in file:
        T = utils.ViaJSONInterface(file,TestMode,MatchLines)
        Tissues[trial] = T.getDataDict()
        TissueFrames[trial] = T.getFrameNumbers()
        #print("\t Load Data: Tissue Keypoints",file)        
        return Tissues, TissueFrames        
    
    def getGrasperJawData(self,trial,TestMode=False,MatchLines=0):
        #print("Starting:getGrasperJawData ->")
        GrasperJaws, GrasperFrames = {}, {}
        file = os.path.join(self.grasperJawDir,trial+".json")
        if not os.path.isfile(file): return {},{}
        #if "frame" not in file:
        J = utils.ViaJSONInterface(file,TestMode,MatchLines)
        GrasperJaws[trial] = J.getDataDict()
        GrasperFrames[trial] = J.getFrameNumbers()
        #print("\t Load Data: Grasper Jaws",file)
        return GrasperJaws, GrasperFrames

    def fileID_and_Epoch(self, filename):
        filename = os.path.basename(filename)
        file = filename.replace(".json","")
        file_s = file.split("_")
        return "_".join(file_s[0:-1]), file_s[-1]

    def fileID(self, filename):
        filename = os.path.basename(filename)
        file = filename.replace(".json","")
        return file
    
    def getContourData(self,TRIAL,ContourFiles,RingFile, label_classes):
        DeeplabVIARings = {}
        DeeplabVIAPoints = {}
        DeeplabVIAFrames = {}

        for file in ContourFiles:
            label_class = os.path.basename(os.path.dirname(file))
            if "ring" in label_class:
                J = utils.VIARingJSON(file)
                if TRIAL not in DeeplabVIARings.keys():
                    DeeplabVIARings[TRIAL] = {}
                R4Dict,R5Dict,R6Dict,R7Dict =  J.getRingsPoints()
                #[R4Frames,R5Frames,R6Frames,R7Frames] = J.getFrameNumbers()                    
                DeeplabVIARings[TRIAL]["Ring_4"] = R4Dict
                DeeplabVIARings[TRIAL]["Ring_5"] = R5Dict
                DeeplabVIARings[TRIAL]["Ring_6"] = R6Dict
                DeeplabVIARings[TRIAL]["Ring_7"] = R7Dict
                    #DeeplabVIARings[file.replace(".json","")][ringClass] = J.getFrameNumbers()
                #print("\t Load data: dl_rings",file,label_class)
            else:
                J = utils.VIAPolyJSON(file)                
                if TRIAL not in DeeplabVIAPoints.keys():
                    DeeplabVIAPoints[TRIAL] = {}
                if TRIAL not in DeeplabVIAFrames.keys():
                    DeeplabVIAFrames[TRIAL] = {}
                DeeplabVIAPoints[TRIAL][label_class] = J.getDataDict()
                DeeplabVIAFrames[TRIAL][label_class] = J.getFrameNumbers()
                #print("\t '%' Load data: dl_points",file,label_class)

        if RingFile != "":
            J = utils.VIARingJSON(RingFile)
            if TRIAL not in DeeplabVIARings.keys():
                DeeplabVIARings[TRIAL] = {}
            R4Dict,R5Dict,R6Dict,R7Dict =  J.getRingsPoints()               
            DeeplabVIARings[TRIAL]["Ring_4"] = R4Dict
            DeeplabVIARings[TRIAL]["Ring_5"] = R5Dict
            DeeplabVIARings[TRIAL]["Ring_6"] = R6Dict
            DeeplabVIARings[TRIAL]["Ring_7"] = R7Dict

        return DeeplabVIAPoints, DeeplabVIAFrames, DeeplabVIARings

    def getFilenamesinTask(self):
        Dirs = []
        oldRoot = ""
        for root, dirs, files in os.walk(self.imagesDir):
            Dirs = dirs
            oldRoot = root
            break
        return Dirs

    def GenerateContextTrial(self, TRIAL, FRAME_NUMS,label_classes, ContourFiles, RingFile, SAVE=False, GENERATE_IMAGES=False):
        count = 0
        #VIA is a labeling app we used to manually annotate Tissue points and Grasper Ends  
        # [Knot_Tying_S01_T01]["100"] = [Points]
        DeeplabVIAPoints = {}
        DeeplabVIAFrames = {}
        DeeplabVIARings = {}
        
        Tissues, TissueFrames = self.getTissueData(TRIAL) # tissue points 
        GrasperJaws, GrasperFrames = self.getGrasperJawData(TRIAL) # grasper points
        DeeplabVIAPoints, DeeplabVIAFrames, DeeplabVIARings  = self.getContourData(TRIAL,ContourFiles,RingFile,label_classes) # We process the output of contours.py here

        # at this point, you should have all of the contour and VIA labels (grasper jaw, tissue points)       
        # FRAME_NUMS: These are all the trial we'll generate context labels for. We get this list from the images folder
       
        #print("Trials:",FRAME_NUMS)
        #TrialRoot = os.path.join(self.imagesDir,TRIAL)
        contextLines = []
        ctxFName = os.path.join(self.ctxConsensusDir,TRIAL+".txt")
        ctxPredFName = os.path.join(self.ctxPredDir,TRIAL+".txt")
        if(os.path.isfile(ctxPredFName)):
            os.remove(ctxPredFName)        
        if(not os.path.isdir(self.ctxPredDir)):
            path = pathlib.Path(self.ctxPredDir)
            path.mkdir(parents=True, exist_ok=True)

        if(not os.path.isdir(self.imagePredDir)):
            path = pathlib.Path(self.imagePredDir)
            path.mkdir(parents=True, exist_ok=True)
        
        framesProcessed = []
        frameNum = 0
        currentRing = 7
        for file in FRAME_NUMS:
            #print("\tProcessing",file)            
            frameNumber = int(file) # has to be a number to index into arrays
            file = "frame_"+file+".png"
            frameNum+=1
            video_frame = os.path.join(self.imagesDir,file)
            video_frame_prediction = os.path.join(self.imagePredDir,file)
            
            if "Suturing" in self.task: 
                TissueClosestIndex = TissueFrames[TRIAL][0]
                tfs = TissueFrames[TRIAL]
                TissueClosestIndex = self.findClosestIndex(frameNumber,tfs)                    
                TissuePoints = Tissues[TRIAL][str(TissueClosestIndex)]
                GrasperJawPoints = GrasperJaws[TRIAL][str(TissueClosestIndex)]
                #print("Drawing Segmentation labels and Keypoints:", os.path.basename(root),file)
            else:
                gfs = GrasperFrames[TRIAL]
                GrasperClosestIndex = self.findClosestIndex(frameNumber,gfs)              
                GrasperJawPoints = GrasperJaws[TRIAL][str(GrasperClosestIndex)]
            
            # All _dl_points contains the contours that are applicable for this Task and Trial combo                    
            All_dl_points = DeeplabVIAPoints[TRIAL] #["class"]["frame"] = list of points
            if "Needle" in self.task:
                All_ring_points = DeeplabVIARings[TRIAL]
                try:
                    Ring4Points = All_ring_points["Ring_4"][str(frameNumber)]
                    Ring5Points = All_ring_points["Ring_5"][str(frameNumber)]
                    Ring6Points = All_ring_points["Ring_6"][str(frameNumber)]
                    Ring7Points = All_ring_points["Ring_7"][str(frameNumber)]
                except Exception as e:
                    print(e,"in RingPoints")
                    Ring4Points = {}
                    Ring5Points = {}
                    Ring6Points = {}
                    Ring7Points = {}


            threadMaskImage =  os.path.join(self.mask_dir,"thread",TRIAL,file) 
            if not os.path.isfile(threadMaskImage):
                continue
            else:
                framesProcessed.append(file)
                pass                       
            annotationFile = os.path.join(self.cogitoDir,TRIAL, utils.imageToJSON(file))
            

            # Getting particular contours (array of points)
            try:
                LgrasperPoints = All_dl_points["leftgrasper"][str(frameNumber)]
            except Exception as e:
                #print(e,"in LgrasperPoints") # missing mask
                LgrasperPoints = {}

            try:
                RgrasperPoints = All_dl_points["rightgrasper"][str(frameNumber)]
            except Exception as e:
                #print(e,"in RgrasperPoints")  # missing mask
                RgrasperPoints = {}

            if "Needle" in self.task or "Suturing" in self.task:
                try:                        
                    NeedlePoints = All_dl_points["needle"][str(frameNumber)]
                except Exception as e:
                    #print(e,"in NeedlePoints")  # missing mask
                    NeedlePoints = {}

            CtxI = utils.ContextInterface2(ctxFName)
            J = utils.JSONInterface(annotationFile)

            # gtPolygons are Ground Truth contour points for the cogito labels
            gtPolygons = J.getPolygonsDict(); # graspers only in KT, 

            # gtKeypoints are Ground Truth points from cogito labels
            gtKeypoints = J.getKeyPointsDict(); # None in KT,
            cn,polylineSeries = J.getPolyLines();
            SingleThreadX = []
            SingleThreadY = []
            for i in range(len(polylineSeries)):
                l = len(polylineSeries)
                for j in range(0,len(polylineSeries[i]),2):
                    SingleThreadX.append(polylineSeries[i][j])
                    SingleThreadY.append(polylineSeries[i][j+1])
            SingleThreadPoints = [(SingleThreadX[i],SingleThreadY[i]) for i in range(len(SingleThreadX))]

            TContours = self.getThreadContours(threadMaskImage)
            ThreadContours = []
            minArea = 80
            for k in range(len(TContours)):                    
                cnt = TContours[k]
                area = cv.contourArea(cnt)
                if area >= minArea:
                    ThreadContours.append(cnt)


            # Getting grasper open/closed from grasper points
            L_Gripping, R_Gripping, L_Dist,R_Dist, Grasper_DistX,Grasper_DistY = self.processGrasperData(GrasperJawPoints)              
                
            # pred has all of the polygons from Zoey's masks
            # gt has all of the polygons from cogito
            pred, gt = self.GetCommonShapes(gtPolygons,gtKeypoints,SingleThreadPoints,polylineSeries,ThreadContours,LgrasperPoints,RgrasperPoints)

            # maskify Thread
            if("Knot" in self.task):
                #pred, gt = self.GetKTShapes(gtPolygons,gtKeypoints,SingleThreadPoints,ThreadContours,LgrasperPoints,RgrasperPoints)     
                
                #dev                    
                ctxPredLine, LG_inter_T, RG_inter_T = self.GenerateContextLineKT(pred, gt ,L_Gripping,R_Gripping,frameNumber,contextLines,Grasper_DistX,Grasper_DistY)    

                #GT                    
                #ctxPredLine, LG_inter_T, RG_inter_T = self.GenerateContextLineKT(gt,pred, L_Gripping,R_Gripping,frameNumber,contextLines,Grasper_DistX)                         
                
                contextLines.append(ctxPredLine)
                if GENERATE_IMAGES: self.DrawSingleImageContextKT(pred, gt,GrasperJawPoints,video_frame,video_frame_prediction,CtxI,ctxPredLine,frameNumber,L_Gripping,R_Gripping,LG_inter_T, RG_inter_T,Grasper_DistX,Grasper_DistY)
            
            if("Needle" in self.task):
                ringShapes, ringShapes_gt = self.GetRingShapes(Ring4Points,Ring5Points,Ring6Points,Ring7Points,gtPolygons)
                needleShape, needleShape_gt = self.GetNeedleShapes(NeedlePoints,gtPolygons)
                #print(needleShape.type)
                #gt, pred, ringShapes_gt, ringShapes, needleShape_gt, needleShape -> GT Test
                #ctxPredLine, LG_inter_T, RG_inter_T,messages = "",0,0,[]                    # this causes list error, switching gt with pred
                
                #pred, gt, ringShapes, ringShapes_gt, needleShape, needleShape_gt -> dev
                ctxPredLine, LG_inter_T, RG_inter_T,messages = self.GenerateContextLineNP(pred, gt, ringShapes, ringShapes_gt, needleShape, needleShape_gt, L_Gripping,R_Gripping,frameNumber,contextLines,Grasper_DistX,currentRing)                        
                #gt, pred, ringShapes_gt, ringShapes, needleShape_gt, needleShape -> GT Test 
                #ctxPredLine, LG_inter_T, RG_inter_T,messages = self.GenerateContextLineNP(gt, pred, ringShapes_gt, ringShapes, needleShape_gt, needleShape, L_Gripping,R_Gripping,frameNumber,contextLines,Grasper_DistX,currentRing)

                contextLines.append(ctxPredLine)
                if GENERATE_IMAGES:  self.DrawSingleImageContextNP(pred, gt, ringShapes, ringShapes_gt, needleShape, needleShape_gt,GrasperJawPoints,video_frame,video_frame_prediction,CtxI,ctxPredLine,frameNumber,L_Gripping,R_Gripping,LG_inter_T, RG_inter_T,messages,GT=False)
                #                        DrawSingleImageContextNP(self,pred, gt,ringShapes,ringShapes_gt,needleShape,needleShape_gt,GrasperJawPoints,imageFName,outputFName,CtxI,ctxPredLine,frameNumber,L_Gripping,R_Gripping,LG_inter_T, RG_inter_T,messages,GT=False):
            if("Suturing" in self.task):              
                needleShape, needleShape_gt = self.GetNeedleShapes(NeedlePoints,gtPolygons)                        
                # gt_bisector is the distance 
                gt_bisector, gt_tissue, pred_bisector, pred_tissue,Bisector = self.GetTissueDist(TissuePoints,needleShape, needleShape_gt) 

                # Predicted comparison
                ctxPredLine, LG_inter_T, RG_inter_T,messages = self.GenerateContextLineS(pred, gt ,needleShape,needleShape_gt ,L_Gripping,R_Gripping,frameNumber,contextLines,gt_bisector, gt_tissue, pred_bisector, pred_tissue,Bisector)
                
                # Ground Truth comparison
                # ctxPredLine, LG_inter_T, RG_inter_T,messages = self.GenerateContextLineS(gt, pred, needleShape_gt, needleShape, L_Gripping,R_Gripping,frameNumber,contextLines,gt_bisector, gt_tissue, pred_bisector, pred_tissue,Bisector)
                                        
                #messages.append("LJ Dist:"+"{:.2f}".format(L_Dist) + str(L_Gripping))
                #messages.append("RJ Dist:"+"{:.2f}".format(R_Dist)+ str(R_Gripping))
                #messages.append("D(LG,T)"+"{:.2f}".format(LG_inter_T))
                #messages.append("D(RG,T):"+"{:.2f}".format(RG_inter_T))

                contextLines.append(ctxPredLine)
                if GENERATE_IMAGES: self.DrawSingleImageContextS(pred, gt,needleShape,needleShape_gt,GrasperJawPoints,video_frame,video_frame_prediction,CtxI,ctxPredLine,frameNumber,L_Gripping,R_Gripping,LG_inter_T, RG_inter_T,messages)
            count += 1

        if(len(contextLines) > 2 and SAVE):
            utils.saveAppend(ctxPredFName,contextLines)
        return framesProcessed 

    def getThreadContours(self,threadMaskImage):
        im = cv.imread(threadMaskImage)
        imgray = cv.cvtColor(im,cv.COLOR_RGB2GRAY,0)
        ret, thresh = cv.threshold(imgray, 1, 255, 0)
        ThreadContours, hierarchy = cv.findContours(thresh, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE) 
        return ThreadContours

    def findClosestIndex(self,frameNumber,tfs):
        for i in range(0,len(tfs)):
            if(frameNumber == tfs[i]):
                return tfs[i]

            if(frameNumber < tfs[i]):
                if i == 0: 
                    return tfs[0]
                else:
                    return tfs[i-1]

            if(frameNumber > tfs[i]):
                if (i+1) >= len(tfs):
                    return  tfs[i]

    def distGraspers(self,P):
        P1,P2 = self.getGrasperBisector(P)  #[(c1[0]+c2[0])/2,(c1[1]+c2[1])/2],[(c3[0]+c4[0])/2,(c3[1]+c4[1])/2] 
        return math.hypot(P1[0]-P2[0],P1[1]-P2[1]),P1[0]-P2[0],P1[1]-P2[1]

    def getGrasperBisector(self,Points):
        c1 = Points[0]
        c2 = Points[1]

        c3 = Points[-2]
        c4 = Points[-1]

        return [(c1[0]+c2[0])/2,(c1[1]+c2[1])/2],[(c3[0]+c4[0])/2,(c3[1]+c4[1])/2] 

    def getTissueBisector(self,Points):
        c1 = Points[0]
        c2 = Points[1]

        c3 = Points[-2]
        c4 = Points[-1]

        return [(c1[0]+c2[0])/2,(c1[1]+c2[1])/2],[(c3[0]+c4[0])/2,(c3[1]+c4[1])/2] 

    def processGrasperData(self,GrasperJawPoints):
        try:
            L_Dist = utils.distTwoPoints(GrasperJawPoints[2],GrasperJawPoints[3])
            R_Dist = utils.distTwoPoints(GrasperJawPoints[0],GrasperJawPoints[1])
            Grasper_Dist,Grasper_DistX,Grasper_DistY = self.distGraspers(GrasperJawPoints)
        except Exception as e:
            L_Dist = 0
            R_Dist = 0
        PARAM_JAW_DIST = 18
        if(L_Dist < PARAM_JAW_DIST):
            L_Gripping = True
        else: 
            L_Gripping = False
        if(R_Dist < PARAM_JAW_DIST):
            R_Gripping = True
        else:
            R_Gripping = False
        return L_Gripping, R_Gripping, L_Dist,R_Dist, Grasper_DistX, Grasper_DistY

    def GetTissueDist(self,TissuePoints,needleShape, needleShape_gt):
        gt_bisector, gt_tissue, pred_bisector, pred_tissue = 1000,1000,1000,1000
        #if not isinstance(needleShape,list):
        #    for n in needleShape.geoms:

        # P1 and P2 are the ends of a perpendicular bisector of all of the Tissue points
        P1,P2 = self.getTissueBisector(TissuePoints)
        p1=np.array(P1)
        p2=np.array(P2)
        p3=[(p1[0]+p2[0])/2,(p1[1]+p2[1])/2]
        # line bisecting tissue points
        Bisector = geo.LineString([p1,p2,p3])

        if not isinstance(needleShape,list):
            if not isinstance(needleShape,Polygon):
                for n in needleShape.geoms:
                    d = n.distance(Bisector)
                    if d < pred_bisector:
                        pred_bisector = d
            else:
                d = needleShape.distance(Bisector)
                if d < pred_bisector:
                    pred_bisector = d
        if not isinstance(needleShape_gt,list):
            for n in needleShape_gt.geoms:
                d = n.distance(Bisector)
                if d < gt_bisector:
                    gt_bisector = d
        #min_needle_center_dist_point = np.abs(np.cross(p2-p1,p3-p1)/np.linalg.norm(p2-p1))

        for tp in TissuePoints:
            P = geo.Point(tp)
            if not isinstance(needleShape,list):
                if not isinstance(needleShape,Polygon):
                    for n in needleShape.geoms:
                        d = n.distance(P)
                        if d < pred_tissue:
                            pred_tissue = d
                else:
                    d = needleShape.distance(P)
                    if d < pred_tissue:
                        pred_tissue = d

            if not isinstance(needleShape_gt,list):
                for n in needleShape_gt.geoms:
                    d = n.distance(P)
                    if d < gt_tissue:
                        gt_tissue = d
        # gt_bisector is distance from cogito needle to Tissue bisector
        # gt_tissue is distance from cogito needle to Tissue points

        # pred_bisector is distance from Zoey's needle mask to Tissue bisector
        # pred_tissue is distance from Zoey's needle mask to Tissue points

        return gt_bisector, gt_tissue, pred_bisector, pred_tissue,Bisector
            
    def GenerateContextLineS(self,pred, gt,needleShape,needleShape_gt ,L_Gripping,R_Gripping,frameNumber,contextLines,gt_bisector, gt_tissue, pred_bisector, pred_tissue,Bisector, GT=False):
        def last5thState(s):
            return s.split(" ")[-1]   
        [LG_dl,RG_dl,T_dl] = pred
        [LG_Group_gt,RG_Group_gt,T_Group_gt] = gt 
        # if pred_bisector, pred_tissue are both 0 -> needle on top of the canvas
        messages = []
        Faulty = False
        if GT:
            RG_inter_T = 0
            #RingDistances_L = [ min([LG_dl.distance(shape) for shape in R_GROUP ])  for R_GROUP in ringShapes_gt]
            #RingDistances_R = [ min([RG_dl.distance(shape) for shape in R_GROUP ])  for R_GROUP in ringShapes_gt]
            NeedleDistances_L =  min([LG_dl.distance(shape) for shape in needleShape_gt if not isinstance(needleShape_gt,list)] )
            NeedleDistances_R =  min([RG_dl.distance(shape) for shape in needleShape_gt if not isinstance(needleShape_gt,list)] )
        else:
            if not isinstance(LG_dl,list) :
                #if len(LG_dl.geoms) > 0:
                LG_dist_T = LG_dl.distance(T_dl)

                #if(len(LG_dl.geoms))>0:
                    #LG_x_center,LG_y_center = LG_dl.geoms[0].centroid.x,LG_dl.geoms[0].centroid.y     
                #    pass
                #else:
                    #LG_x_center,LG_y_center = 400,200
                #    pass

            else: 
                LG_dist_T = 100

            if not isinstance(RG_dl,list) :
                #if len(LG_dl.geoms) > 0:
                RG_dist_T = RG_dl.distance(T_dl)
            else: 
                RG_dist_T = 100           
            
            if not isinstance(needleShape,list):
                global LG_dist_N_last,RG_dist_N_last
                try:
                    LG_dist_N =  min([LG_dl.distance(shape) for shape in needleShape.geoms ] )
                    RG_dist_N =  min([RG_dl.distance(shape) for shape in needleShape.geoms] )
                    LG_dist_N_last,RG_dist_N_last = LG_dist_N,RG_dist_N
                except Exception as e:
                    LG_dist_N,RG_dist_N = LG_dist_N_last,RG_dist_N_last

                global LG_inter_N_last,RG_inter_N_last
                try:
                    LG_inter_N =  max([RG_dl.intersection(make_valid(shape)).area for shape in needleShape.geoms] ) 
                    RG_inter_N =  max([LG_dl.intersection(make_valid(shape)).area for shape in needleShape.geoms] )
                    LG_inter_N_last,RG_inter_N_last = LG_inter_N,RG_inter_N
                except Exception as e:
                    #RG_inter_N =  max([LG_dl.intersection(make_valid(shape)).area for shape in needleShape.geoms] )
                    #LG_inter_N =  max([RG_dl.intersection(make_valid(shape)).area for shape in needleShape.geoms] ) 
                    #print(e,"could not load a shape in GenerateContextLineS")
                    #messages.append("missing contour")
                    #Faulty = True
                    LG_inter_N,RG_inter_N = LG_inter_N_last,RG_inter_N_last

                N_inter_TS = pred_tissue < 2 
                scaleF = 1
                messages.append("LG Hold\Contact")
                messages.append("D(LG,N):"+"{:.2f}".format(LG_dist_N/scaleF))
                messages.append("D(LG,T):"+"{:.2f}".format(LG_dist_T))
                messages.append("Inter(LG,N):"+"{:.2f}".format(RG_inter_N/scaleF))
                messages.append("α:"+str(not(L_Gripping)))
                messages.append("")


                messages.append("RG Hold\Contact")
                messages.append("D(RN,N):"+"{:.2f}".format(RG_dist_N/scaleF))
                messages.append("D(RG,T):"+"{:.2f}".format(RG_dist_T))
                messages.append("Inter(RG,N):"+"{:.2f}".format(LG_inter_N/scaleF))
                messages.append("α:"+str(not(R_Gripping)))
                messages.append("")

                messages.append("Needle State")
                messages.append("D(N,Ts):"+"{:.2f}".format(pred_tissue/scaleF))
                #messages.append("N to Bisector"+"{:.2f}".format(pred_bisector))

                global bi_x_last, n_x_last
                try:
                    bi_x,bi_y = Bisector.centroid.x,Bisector.centroid.y
                    n_x,n_y = needleShape.geoms[0].centroid.x,needleShape.geoms[0].centroid.y
                    bi_x_last, n_x_last = bi_x, n_x

                except Exception as e:
                    bi_x, n_x = bi_x_last, n_x_last

                #messages.append("D(N,Ts)"+"{:.2f}".format(pred_tissue))
                messages.append("N.x:"+"{:.2f}   ".format(n_x))
                messages.append("Ts.x:"+"{:.2f}   ".format(bi_x))
                messages.append("N.x<Ts.x:"+str(n_x<bi_x))
                needleShape_last = needleShape
            else:
                #print("AAAAAAAAAAAAAAAAAAAA")
                Faulty = True
            #RingDistances_N = [ min([needleShape.distance(shape) for shape in R_GROUP.geoms if not isinstance(needleShape,list) ])  for R_GROUP in ringShapes if not isinstance(R_GROUP,list)] if ringShapes != [] else []
            #RingInter_N =  [ max([needleShape.intersection(shape).area for shape in R_GROUP.geoms if not isinstance(needleShape,list)])  for R_GROUP in ringShapes  if not isinstance(R_GROUP,list)] if ringShapes != [] else []
                
            

        # This is where we put the predicted context states
        L_G_Touch = 0
        L_G_Hold = 0
        R_G_Touch = 0
        R_G_Hold = 0
        Extra_State = 0 #Needle / Knot State
        INTER_THRESH = 2
        global Suturing_Needle_out_of_Tissue
        global Suturing_Needle_Right_of_Tissue

        if not Faulty:
            if(R_Gripping):                
                if(RG_dist_N < INTER_THRESH ):
                    R_G_Hold = 2
                elif(RG_dist_T < INTER_THRESH):
                    R_G_Hold = 3
            else: #Right not gripping
                if(RG_dist_N < INTER_THRESH):
                    R_G_Touch = 2
                elif(RG_dist_T < INTER_THRESH):
                    R_G_Touch = 3

            if(L_Gripping):            
                if(LG_dist_N < INTER_THRESH):
                    L_G_Hold = 2
                elif(LG_dist_T < INTER_THRESH):
                    L_G_Hold = 3
            else:#Left not gripping
                if(LG_dist_N < INTER_THRESH):
                    L_G_Touch = 2
                elif(LG_dist_T < INTER_THRESH):
                    L_G_Touch = 3

            if not Suturing_Needle_out_of_Tissue:
                Extra_State = 2
                if L_G_Touch == 2:
                    Suturing_Needle_out_of_Tissue = True
                if LG_dist_N < 200:
                    Suturing_Needle_out_of_Tissue = True
            if Suturing_Needle_out_of_Tissue:
                if len(contextLines) > 0:
                    last = last5thState(contextLines[-1])
                else:
                    last = "0"
            
                if(bi_x > n_x):
                    Suturing_Needle_Right_of_Tissue = False
                else:
                    Suturing_Needle_Right_of_Tissue = True

                if last == "0" and (pred_tissue < 10 and pred_bisector>7 and Suturing_Needle_Right_of_Tissue):
                    Extra_State = 1
                elif last == "1" and (not Suturing_Needle_Right_of_Tissue):
                   
                    if(pred_tissue < 9):
                        Extra_State = 1
                    else:
                        Extra_State = 0
                elif last == "1":
                    if(pred_tissue < 10):
                        Extra_State = 1
                    else:
                        Extra_State = 2

                elif last == "2" and (not Suturing_Needle_Right_of_Tissue):
                    if not R_Gripping:
                        Extra_State = 0
                    else:
                        Extra_State = 2
                elif last == "2":
                    if RG_dist_N > 40 or not R_Gripping:
                        Extra_State = 0
                    else:
                        Extra_State = 2

        elif (len(contextLines) > 0):
            s_ = contextLines[-1].split(" ")
            L_G_Hold =s_[1]
            L_G_Touch = s_[2]
            R_G_Hold = s_[3]
            R_G_Touch = s_[4]
        else:
            L_G_Hold = 0
            L_G_Touch =0
            R_G_Hold = 0
            R_G_Touch =0
            Extra_State=2
        
        return ""+ str(frameNumber) + " " + str(L_G_Hold) + " " + str( L_G_Touch) + " " + str(R_G_Hold) + " " + str(R_G_Touch) + " " + str(Extra_State), LG_dist_T,RG_dist_T,messages
       
    def GenerateContextLineNP(self,pred, gt, ringShapes,ringShapes_gt,needleShape,needleShape_gt ,L_Gripping,R_Gripping,frameNumber,contextLines,Grasper_DistX,currentRing, GT=False):
        
        [LG_dl,RG_dl,T_dl] = pred
        [LG_Group_gt,RG_Group_gt,T_Group_gt] = gt  
        [R4_Group,R5_Group,R6_Group,R7_Group] = ringShapes
        [R4_Group_gt,R5_Group_gt,R6_Group_gt,R7_Group_gt] = ringShapes_gt
        messages = []
        Faulty = False
        
        if not isinstance(LG_dl,list):
            if T_dl.area > 1:
                LG_inter_T = LG_dl.distance(T_dl)
            else:
                LG_inter_T = 10
        else:
            LG_inter_T = 20

        if not isinstance(RG_dl,list):
            if T_dl.area > 1:
                RG_inter_T = RG_dl.distance(T_dl)
            else:
                RG_inter_T = 10
        else:
            RG_inter_T = 20

        '''
        
        if isinstance(LG_dl,MultiPolygon):
            for geo in LG_dl.geoms:
                x,y = geo.exterior.xy
                plt.plot(x,y,color='blue')
        else:
            x,y = LG_dl.coors[0], LG_dl.coors[1]
            plt.plot(x,y,color='blue')

        if isinstance(RG_dl,MultiPolygon):
            for geo in RG_dl.geoms:
                x,y = geo.exterior.xy
                plt.plot(x,y,color='red')
        else:
            x,y = RG_dl.coors[0], RG_dl.coors[1]
            plt.plot(x,y,color='red')

        if isinstance(T_dl,MultiPolygon):
            for geo in T_dl.geoms:
                x,y = geo.exterior.xy
                plt.plot(x,y,color='green')
        else:
            x,y = T_dl.coors[0], T_dl.coors[1]
            plt.plot(x,y,color='green')

        plt.show()

        '''

        '''
        if not isinstance(LG_dl,list):
            if isinstance(LG_dl,Polygon):
                LG_x_center,LG_y_center = LG_dl.centroid.x,LG_dl.centroid.y 
            else:
                if len(LG_dl.geoms) > 0:
                    LG_x_center,LG_y_center = LG_dl.geoms[0].centroid.x,LG_dl.geoms[0].centroid.y     
        else:
            LG_x_center,LG_y_center = 400,200
        '''
        
        try:
            RingDistances_L = [ min([LG_dl.distance(shape) for shape in R_GROUP.geoms if not isinstance(LG_dl,list)])  for R_GROUP in ringShapes if not isinstance(R_GROUP,list) ] if ringShapes != [] else []
            RingDistances_R = [ min([RG_dl.distance(shape) for shape in R_GROUP.geoms if not isinstance(RG_dl,list)])  for R_GROUP in ringShapes if not isinstance(R_GROUP,list) ] if ringShapes != [] else []  
            
            NeeldeDistances_L = [ min([LG_dl.distance(shape) for shape in N_GROUP.geoms if not isinstance(LG_dl,list)])  for N_GROUP in needleShape if not isinstance(N_GROUP,list) ] if needleShape != [] else []
            NeeldeDistances_R = [ min([RG_dl.distance(shape) for shape in N_GROUP.geoms if not isinstance(RG_dl,list)])  for N_GROUP in needleShape if not isinstance(N_GROUP,list) ] if needleShape != [] else []  
            NeeldeDistances_L = min(NeeldeDistances_L)
            NeeldeDistances_R = min(NeeldeDistances_R)
            
            
            RingDistances_N = []
            absMinDistN = 10000
            ringID = -1
            for i in range(len(ringShapes)):
                R_GROUP = ringShapes[i]
                if not isinstance(R_GROUP,list) and not isinstance(needleShape,list):
                    currMin = min([needleShape.distance(shape) for shape in R_GROUP.geoms ])
                    RingDistances_N.append(currMin)
                    if currMin < absMinDistN:
                        ringID = i
                        absMinDistN = currMin
            #closestRingCenterX,closestRingCenterY = ringShapes[ringID].geoms[0].centroid.x,ringShapes[ringID].geoms[0].centroid.x,
            global closestRingCenterX_last,closestRingCenterY_last
            if isinstance(ringShapes[ringID],list):
                closestRingCenterX,closestRingCenterY = closestRingCenterX_last,closestRingCenterY_last
            else:
                closestRingCenterX,closestRingCenterY = ringShapes[ringID].centroid.x,ringShapes[ringID].centroid.y
                closestRingCenterX_last,closestRingCenterY_last = closestRingCenterX,closestRingCenterY
            

            RingXCoors = [ np.average([ shape.centroid.x for shape in R_GROUP.geoms ]) for R_GROUP in ringShapes if( not isinstance(R_GROUP,list)) ] if ringShapes != [] else []

            if isinstance(needleShape,list):
                RingDistances_N = [100]
                RingInter_N = [0]
            else:
                #needleShape = make_valid(needleShape)
                RingDistances_N = [min([needleShape.distance(make_valid(shape)) for shape in R_GROUP.geoms])  for R_GROUP in ringShapes  if( not isinstance(R_GROUP,list))] 
                RingInter_N =  [ max([needleShape.intersection(make_valid(shape)).area for shape in R_GROUP.geoms])  for R_GROUP in ringShapes  if( not isinstance(R_GROUP,list))]
            minLRing = min(RingDistances_L)
            minRRing = min(RingDistances_R)
            minNRing = min(RingDistances_N)
            maxInter_RN = max(RingInter_N)
            messages.append("Min L Ring:"+"{:.2f}".format(minLRing))
            messages.append("Min R Ring:"+"{:.2f}".format(minRRing))
            messages.append("Min N Ring:"+"{:.2f}".format(minNRing))
            messages.append("Max RN Inter:"+"{:.2f}".format(maxInter_RN))
            global x_center_last,y_center_last
            if isinstance(needleShape,list):
                x_center,y_center = x_center_last,y_center_last
            else:
                x_center,y_center = needleShape.centroid.x,needleShape.centroid.y
                x_center_last,y_center_last = x_center,y_center


            dists = [ abs(x_center-p) for p in RingXCoors]
            dists2 = [ abs(x_center-p) for p in RingXCoors]
            DistanceToRingCenter = min(dists)
            DistanceToRingInCenter = min(dists2)
            messages.append("ToRing:"+"{:.2f}".format(DistanceToRingCenter))
            messages.append("ToVoid:"+"{:.2f}".format(DistanceToRingInCenter))
            
        except Exception as e:
            #print(e,"could not load a shape in GenerateContextLineNP")
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            #print(exc_type, fname, exc_tb.tb_lineno)
            messages.append("missing contour")
            Faulty = True


        def last5thState(s):
            return s.split(" ")[-1]            
        
        # This is where we put the predicted context states
        L_G_Touch = 0
        L_G_Hold = 0
        R_G_Touch = 0
        R_G_Hold = 0
        Extra_State = 0 #Needle / Knot State
        INTER_THRESH = 1
        RING_THRESH = 2
        
        if not Faulty:
            #print("\t===>Ignoring Needle")
            if(R_Gripping):
                if(NeeldeDistances_R < INTER_THRESH):
                   R_G_Hold = 2 
                elif(minRRing < INTER_THRESH):
                    R_G_Hold = 2
                elif(RG_inter_T <INTER_THRESH ):
                    R_G_Hold = 3
            else: #Right not gripping
                if(NeeldeDistances_L < INTER_THRESH):
                   L_G_Hold = 2 
                elif(minRRing <INTER_THRESH):
                    R_G_Touch = 2
                elif(RG_inter_T <INTER_THRESH):
                    R_G_Touch = 3
            if(L_Gripping):
                if(NeeldeDistances_L < INTER_THRESH):
                   L_G_Hold = 2             
                elif(minLRing  <INTER_THRESH):
                    L_G_Hold = 2
                elif(LG_inter_T <INTER_THRESH):
                    L_G_Hold = 3
            else:#Left not gripping
                if(NeeldeDistances_L < INTER_THRESH):
                   L_G_Hold = 2 
                elif(minLRing  <INTER_THRESH):
                    L_G_Touch = 2
                elif(LG_inter_T  <INTER_THRESH):
                    L_G_Touch = 3
        
        elif (len(contextLines) > 0):
            s_ = contextLines[-1].split(" ")            
            L_G_Hold =s_[1]
            L_G_Touch = s_[2]
            R_G_Hold = s_[3]
            R_G_Touch = s_[4]
        else:
            L_G_Hold = 0
            L_G_Touch =0
            R_G_Hold = 0
            R_G_Touch =0
        
        if(len(contextLines) == 0):
            Extra_State = 0
        else:
            #print("\tNeedle sum, LocalRing sum",needleSum,localRingsMass,"accepted 5th?",str( needleSum > 50 and localRingsMass >20))
            #print("")
            if not Faulty:

                last = last5thState(contextLines[-1])
                if last == "0" and minNRing < 10:
                    Extra_State = 1
                    messages.append(str(last)+":minNRing < 10:"+str(Extra_State))
                elif last == "0":
                    Extra_State = 0
                    messages.append(str(last)+":minNRing < 10E:"+str(Extra_State))
                elif last == "1" and maxInter_RN > 3:
                    Extra_State = 2
                    messages.append(str(last)+":maxInter_RN > 3:"+str(Extra_State))
                elif last == "1" and minNRing > 10:
                    Extra_State = 0
                    messages.append(str(last)+":minNRing > 10:"+str(Extra_State))
                elif last == "1" and (x_center < closestRingCenterX):
                    Extra_State = 8
                    messages.append(str(last)+":x_center < closestRingCenterX:"+str(Extra_State))
                elif last == "1":
                    Extra_State = 1
                    messages.append(str(last)+":E:"+str(Extra_State))
                elif last == "2" and  DistanceToRingInCenter < 10:
                    Extra_State = 0
                elif last == "2" and (not R_Gripping or not L_Gripping):
                    Extra_State = 0
                    messages.append(str(last)+":not R_Gripping or not L_Gripping:"+str(Extra_State))
                elif last == "2" and minNRing > 10:
                    Extra_State = 0
                    messages.append(str(last)+":minNRing > 10:"+str(Extra_State))
                elif last == "2" and maxInter_RN == 0:
                    Extra_State = 1
                    messages.append(str(last)+":maxInter_RN == 0:"+str(Extra_State))
                elif last == "2": 
                    Extra_State = 2
                    messages.append(str(last)+":E:"+str(Extra_State))
             
            else:
                last = last5thState(contextLines[-1])
                
                Extra_State = last5thState(contextLines[-1])
                messages.append(str(last)+":Faulty:"+str(Extra_State))

            if not Faulty and maxInter_RN > 20:
                Extra_State = 2
                messages.append(str(last)+":not Faulty and maxInter_RN > 20:"+str(Extra_State))
            
        #if(R_G_Hold == 2 and L_G_Hold == 2 and min_Tissue_Dist < 5 and needle_center_dist > 20):
        #    Extra_State = 2

        return ""+ str(frameNumber) + " " + str(L_G_Hold) + " " + str(L_G_Touch) + " " + str(R_G_Hold) + " " + str(R_G_Touch) + " " + str(Extra_State), LG_inter_T, RG_inter_T, messages 

    def GenerateContextLineKT(self,pred, gt ,L_Gripping,R_Gripping,frameNumber,contextLines,Grasper_DistX, Grasper_DistY, GT=False):
        [LG_dl,RG_dl,T_dl] = pred
        [LG_Group_gt,RG_Group_gt,T_Group_gt] = gt  
        if GT:
            RG_inter_T = 0
        else:

            #RG_inter_T = RG_dl.distance(T_dl)
            #LG_inter_T = LG_dl.distance(T_dl)

            if not isinstance(RG_dl,list) :
                RG_inter_T = RG_dl.distance(T_dl)
            else:
                RG_inter_T = 100

            if not isinstance(LG_dl,list) :
                LG_inter_T = LG_dl.distance(T_dl)
            else:
                LG_inter_T = 100
            #P1 = LG_dl.centroid
            #P2 = RG_dl.centroid
            #Grasper_DistX = P1.distance(P2)

        def last5thState(s):
            return s.split(" ")[-1]
        # This is where we put the predicted context states
        L_G_Touch = 0
        L_G_Hold = 0
        R_G_Touch = 0
        R_G_Hold = 0
        Extra_State = 0 #Needle / Knot State
        INTER_THRESH_L = 2.5
        INTER_THRESH_R = 2.5
        
        if(R_Gripping):
            if(RG_inter_T < INTER_THRESH_R ):
                R_G_Hold = 3
        else: #Right not gripping
            if(RG_inter_T < INTER_THRESH_R):
                R_G_Touch = 3
        if(L_Gripping):
            if(LG_inter_T  < INTER_THRESH_L):
                L_G_Hold = 3
        else:#Left not gripping
            if(LG_inter_T  < INTER_THRESH_L):
                L_G_Touch = 3
        if(len(contextLines) == 0):
            Extra_State = 0
        else:
            last = last5thState(contextLines[-1])
            if last == "0" and Grasper_DistX < - 18 and Grasper_DistY < 68 and Grasper_DistY > 0:
                Extra_State = 1 #+wrapped
            elif last == "1" and Grasper_DistX > 115:
                Extra_State = 2 # lose
            elif last == "1":
                Extra_State = 1
            elif last == "2" and Grasper_DistX > 120:
                Extra_State = 3 # tight
            elif last == "2":
                Extra_State = 2 # lose
            elif last == "3" and (not L_Gripping or not R_Gripping):                
                Extra_State = 0 # tight
            elif last == "3" and (L_G_Hold==0):
                Extra_State = 0 # tight
            elif last == "3":
                Extra_State = 3 # lose
        return ""+ str(frameNumber) + " " + str(L_G_Hold) + " " + str(L_G_Touch) + " " + str(R_G_Hold) + " " + str(R_G_Touch) + " " + str(Extra_State), LG_inter_T, RG_inter_T
    
    def DrawSingleImageContextNP(self,pred, gt,ringShapes,ringShapes_gt,needleShape,needleShape_gt,GrasperJawPoints,imageFName,outputFName,CtxI,ctxPredLine,frameNumber,L_Gripping,R_Gripping,LG_inter_T, RG_inter_T,messages,GT=False):
        [LG_dl,RG_dl,T_dl] = pred
        [LG_Group_gt,RG_Group_gt,T_Group_gt] = gt
        image = cv.imread(imageFName)
        plt.imshow(image, cmap='gray') 
        if GT:        
            try:
                x,y = unary_union(LG_Group_gt).exterior.xy
                plt.plot(x,y)                
                #plt.plot(LG_Group_gt.centroid.x,LG_Group_gt.centroid.y,)
            except Exception as e:
                print(e,"No LG_Group_gt")

            try:
                x,y = unary_union(RG_Group_gt).exterior.xy
                #plt.plot(RG_Group_gt.centroid.x,RG_Group_gt.centroid.y)
                plt.plot(x,y)
            except Exception as e:
                print(e, "no RG GT annotation")
            try:
                cords = T_Group_gt.coords if len(T_Group_gt) > 1 else [0,0]
                #plt.plot(cords)
            except Exception as e:
                print(e,"probably no thread GT annotation")    
        try:
            for s in LG_dl.geoms:
                x,y = s.exterior.xy
                plt.plot(x,y,color='blue',linewidth=1)
            #x,y = unary_union(LG_dl).exterior.xy
            #plt.plot(x,y)                
        except Exception as e:
            print(e,"No LG DL label: DrawSingleImageContextNP")
        try:
            for s in RG_dl.geoms:
                x,y = s.exterior.xy
                plt.plot(x,y,color='blue',linewidth=1)
            #x,y = unary_union(RG_dl).exterior.xy
            #plt.plot(x,y)
        except Exception as e:
            print(e,"No RG DL label") 
        
        
        if not isinstance(needleShape,list): 
            #if isinstance()
            for s in needleShape.geoms:
                x,y = unary_union(s).exterior.xy
                #x,y = s.coords[0],s.coords[1]
                plt.plot(x,y,color='red',linewidth=1)
        #x,y = unary_union(RG_dl).exterior.xy
        #plt.plot(x,y)
        #except Exception as e:
        #    print(e,"No N DL label") 
        '''
        for ns in needleShape:           

            try:
                x,y = unary_union(ns).exterior.xy
                plt.plot(ns.centroid.x,ns.centroid.y)
                plt.plot(x,y)
            except Exception as e:
                print(e,"No Needle DL label")
        '''

        for ringGoup in ringShapes:
            if isinstance(ringGoup,list):
                for rs in ringGoup:
                    #if not isinstance(rs,list):
                    try:
                        x,y = unary_union(rs).exterior.xy
                        #plt.plot(rs.centroid.x,rs.centroid.y)
                        #plt.circle((rs.centroid.x,rs.centroid.y),1,color='g')
                        plt.plot( rs.centroid.x,rs.centroid.y, ls=' ', marker='o', markersize=5, color='r' )
                        plt.plot(x,y)
                    except Exception as e:
                        print(e,"No Ring label")
            else: 
                for rs in ringGoup.geoms:
                    #if not isinstance(rs,list):
                    try:
                        x,y = unary_union(rs).exterior.xy
                        #plt.plot(rs.centroid.x,rs.centroid.y)
                        #plt.circle((rs.centroid.x,rs.centroid.y),1,color='g')
                        plt.plot( rs.centroid.x,rs.centroid.y, ls=' ', marker='o', markersize=5, color='r' )
                        plt.plot(x,y)
                    except Exception as e:
                        print(e,"No Ring label")

        scale = 1
        linewidth = 1 
        #unaryThread = unary_union(T_dl.geoms)
        #print("thread geoms:",T_dl.geoms,"unaryThread",unaryThread.is_valid,type(unaryThread))
        if isinstance(T_dl,Polygon):
            x,y = T_dl.coords[0],T_dl.coords[1]
            x = [xx*scale for xx in x]
            y = [yy*scale for yy in y]
            plt.plot(x,y,color="purple",linewidth=linewidth)
        else:
            for thread in T_dl.geoms:
                try:
                    x,y = unary_union(thread).exterior.xy
                    x = [xx*scale for xx in x]
                    y = [yy*scale for yy in y]
                    plt.plot(x,y,color="purple",linewidth=linewidth)
                except Exception as e:
                    print(e,"No Thread label: DrawSingleImageContextNP")

        ctxGT = CtxI.getContext(frameNumber).split(" ")
        #ctxCOMP = CtxICOMP.getContext(frameNumber).split(" ")
        fnum = ctxGT[0] 
        ctxGT.insert(1,"|")
        #ctxCOMP.insert(1,"|")
        ctxPred = ctxPredLine.split(" ")
        ctxPred[0] = ctxGT[0] 
        ctxPred.insert(1,"|")

        contextMessage = ["Ground Truth:"," ".join(ctxGT),"Pred Context:"," ".join(ctxPred)]
        offset = 1
        fs = 7
        ctxOffset = 350
        caxis = plt.gca()
        caxis.add_patch(Rectangle((0 , -10), 390, 130, facecolor="white"))
        caxis.add_patch(Rectangle((0 , 350), 160, 130, facecolor="white"))

        for s in contextMessage:
            #x = 640 - 250
            x = 10
            y = ctxOffset + 21 * offset; 
            plt.text(x,y,s,fontsize=8,color='black')
            offset+=1   


        strArr = ["LG->T:"+str(LG_inter_T),"RG->T:"+str(RG_inter_T)]
        offset = 1        
        for s in strArr:
            x = 10
            y = 22 * offset; 
            plt.text(x,y,s,fontsize=fs,color='black')
            offset+=1

        offset = 1
        for s in messages:
            x = 140
            y = 22 * offset; 
            plt.text(x,y,s,fontsize=fs,color='black')
            offset+=1

        plt.savefig(outputFName)
        plt.close()

    def DrawSingleImageContextS(self,pred, gt,needleShape,needleShape_gt,GrasperJawPoints,imageFName,outputFName,CtxI,ctxPredLine,frameNumber,L_Gripping,R_Gripping,LG_inter_T, RG_inter_T,messages,GT=False):
        [LG_dl,RG_dl,T_dl] = pred
        [LG_Group_gt,RG_Group_gt,T_Group_gt] = gt
        image = cv.imread(imageFName)
        plt.imshow(image, cmap='gray')

        if GT:
            try:
                x,y = unary_union(LG_Group_gt).exterior.xy
                plt.plot(x,y)                
                plt.plot(LG_Group_gt.centroid.x,LG_Group_gt.centroid.y)
            except Exception as e:
                print(e,"No LG_Group_gt")

            try:
                x,y = unary_union(RG_Group_gt).exterior.xy
                plt.plot(RG_Group_gt.centroid.x,RG_Group_gt.centroid.y)
                plt.plot(x,y)
            except Exception as e:
                print(e, "no RG GT annotation")
            try:
                cords = T_Group_gt.coords if len(T_Group_gt) > 1 else [0,0]
                plt.plot(cords)
            except Exception as e:
                print(e,"probably no thread GT annotation")
    
        scale = 1
        linewidth = 1        

        for g in LG_dl.geoms:
            try:
                x,y = unary_union(g).exterior.xy
                x = [xx*scale for xx in x]
                y = [yy*scale for yy in y]
                plt.plot(x,y,color="green",linewidth=linewidth)
            except Exception as e:
                print(e,"No LG DL label: DrawSingleImageContextS")

        for g in RG_dl.geoms:
            try:
                x,y = unary_union(g).exterior.xy
                x = [xx*scale for xx in x]
                y = [yy*scale for yy in y]
                plt.plot(x,y,color="gold",linewidth=linewidth)
            except Exception as e:
                print(e,"No RG DL label") 

        if not isinstance(needleShape,list):
            for ns in needleShape.geoms:
                try:
                    x,y = unary_union(ns).exterior.xy
                    #plt.plot(ns.centroid.x,ns.centroid.y)
                    x = [xx*scale for xx in x]
                    y = [yy*scale for yy in y]
                    plt.plot(x,y,color="red",linewidth=linewidth)
                except Exception as e:
                    print(e,"No Needle DL label")
        
        #unaryThread = unary_union(T_dl.geoms)
        #print("thread geoms:",T_dl.geoms,"unaryThread",unaryThread.is_valid,type(unaryThread))
        for thread in T_dl.geoms:
            if thread.exterior.xy:
                x,y = thread.exterior.xy
                x = [xx*scale for xx in x]
                y = [yy*scale for yy in y]
                plt.plot(x,y,color="blue",linewidth=linewidth)
        
        ctxGT = CtxI.getContext(frameNumber).split(" ")
        fnum = ctxGT[0] 
        ctxGT.insert(1,"|")
        ctxPred = ctxPredLine.split(" ")
        ctxPred[0] = ctxGT[0] 
        ctxPred.insert(1,"|")

        contextMessage = ["Ground Truth:"," ".join(ctxGT),"","Predicted Context:"," ".join(ctxPred)]
        offset = 1
        fs = 7
        ctxOffset = 360
        caxis = plt.gca()
        caxis.add_patch(Rectangle((0 , 0), 390, 120, facecolor="white"))
        caxis.add_patch(Rectangle((0 , 360), 130, 120, facecolor="white"))
        #caxis.add_patch(Rectangle((640-250, 0), 250, 120, facecolor="white"))
        for s in contextMessage:
            #x = 640 - 250
            x = 10
            y = ctxOffset + 22 * offset; 
            plt.text(x,y,s,fontsize=fs,color='black')
            offset+=1        
        offset = 1
        mLG = messages[0:6]
        mRG = messages[6:12]
        mN = messages[12:]

        for s in mLG:
            x = 10
            y = 22 * offset; 
            plt.text(x,y,s,fontsize=fs,color='black')
            offset+=1

        offset = 1
        for s in mRG:
            x = 140
            y = 22 * offset; 
            plt.text(x,y,s,fontsize=fs,color='black')
            offset+=1
        offset = 1
        for s in mN:
            x = 280
            y = 22 * offset; 
            plt.text(x,y,s,fontsize=fs,color='black')
            offset+=1
        '''
        for s in messages:
            x = 10
            y = 22 * offset; 
            plt.text(x,y,s,fontsize=fs,color='black')
            offset+=1
        '''
        #outPath = os.path.(outputFName,"")

        plt.axis('off')
        plt.savefig(outputFName, bbox_inches='tight')
        #plt.savefig(outputFName)
        plt.close()
                
    def DrawSingleImageContextKT(self, pred, gt,GrasperJawPoints,imageFName,outputFName,CtxI,ctxPredLine,frameNumber,L_Gripping,R_Gripping,LG_inter_T, RG_inter_T,Grasper_DistX,Grasper_DistY,GT=False):
        [LG_dl,RG_dl,T_dl] = pred
        [LG_Group_gt,RG_Group_gt,T_Group_gt] = gt  

        image = cv.imread(imageFName)
        plt.imshow(image, cmap='gray') 
        if GT:
        
            try:
                x,y = unary_union(LG_Group_gt).exterior.xy
                plt.plot(x,y)
            except Exception as e:
                print(e,"No LG_Group_gt")

            try:
                x,y = unary_union(RG_Group_gt).exterior.xy
                plt.plot(x,y)
            except Exception as e:
                print(e, "no RG GT annotation")
            try:
                cords = T_Group_gt.coords if len(T_Group_gt) > 1 else [0,0]
                plt.plot(cords)
            except Exception as e:
                print(e,"probably no thread GT annotation")
    
        scale = 1
        linewidth = 1   

        for g in LG_dl.geoms:
            try:
                x,y = unary_union(g).exterior.xy
                x = [xx*scale for xx in x]
                y = [yy*scale for yy in y]
                plt.plot(x,y,color="green",linewidth=linewidth)
            except Exception as e:
                print(e,"No LG DL label: DrawSingleImageContextS")
       
        for g in RG_dl.geoms:
            try:
                x,y = unary_union(g).exterior.xy
                x = [xx*scale for xx in x]
                y = [yy*scale for yy in y]
                plt.plot(x,y,color="gold",linewidth=linewidth)
            except Exception as e:
                print(e,"No RG DL label") 

        #unaryThread = unary_union(T_dl.geoms)
        #print("thread geoms:",T_dl.geoms,"unaryThread",unaryThread.is_valid,type(unaryThread))
        for thread in T_dl.geoms:
            if thread.exterior.xy:
                x,y = thread.exterior.xy
                x = [xx*scale for xx in x]
                y = [yy*scale for yy in y]
                plt.plot(x,y,color="blue",linewidth=linewidth)
                
        ctxGT = CtxI.getContext(frameNumber).split(" ")
        ctxGT.insert(1,"|")
        ctxPred = ctxPredLine.split(" ")
        ctxPred[0] = ctxGT[0] 
        ctxPred.insert(1,"|")

        
        contextMessage = ["Ground Truth:"," ".join(ctxGT),"","Predicted Context:"," ".join(ctxPred)]
        offset = 1
        fs = 7
        ctxOffset = 360
        caxis = plt.gca()
        caxis.add_patch(Rectangle((0 , 0), 390, 120, facecolor="white"))
        caxis.add_patch(Rectangle((0 , 360), 130, 120, facecolor="white"))

        for s in contextMessage:
            #x = 640 - 250
            x = 10
            y = ctxOffset + 22 * offset; 
            plt.text(x,y,s,fontsize=fs,color='black')
            offset+=1 



        strArr = ["LG->T:"+str(round(LG_inter_T,2)),"RG->T:"+str(round(RG_inter_T,2)),"Grasper_DistX:"+str(Grasper_DistX),"Grasper_DistY:"+str(Grasper_DistY)]
        offset = 1        
        for s in strArr:
            x = 10
            y = 22 * offset; 
            plt.text(x,y,s,fontsize=fs,color='black')
            offset+=1
        
        
        #plt.show()
        plt.savefig(outputFName)
        plt.close()
        
        
        
        '''
        LG_dl_s = gpd.GeoSeries(LG_dl)
        LG_dl_s.plot()
        RG_dl_s = gpd.GeoSeries(RG_dl)
        RG_dl_s.plot()
        T_dl_s = gpd.GeoSeries(T_dl)
        T_dl_s.plot()

        LG_Group_gt_s = gpd.GeoSeries(LG_Group_gt)
        LG_Group_gt_s.plot()
        RG_Group_gt_s = gpd.GeoSeries(RG_Group_gt)
        RG_Group_gt_s.plot()
        T_Group_gt_s = gpd.GeoSeries(T_Group_gt)
        T_Group_gt_s.plot()
        plt.show()
        '''
 
    # All of the methods below return arrays of objects of type geo.Polygon
    # This speeds up computation later
    def GetKTShapes(self,gtPolygons,gtKeypoints,SingleThreadPoints,ThreadContours,LgrasperPoints,RgrasperPoints):
        RG_Group_gt = geo.MultiPolygon([ geo.Polygon( [ (gtPolyRG[i],gtPolyRG[i+1]) for i in range(0,len(gtPolyRG),2)] ) for gtPolyRG in gtPolygons["Right Grasper"]]) if "Right Grasper" in gtPolygons.keys() else []
        LG_Group_gt = geo.MultiPolygon([ geo.Polygon( [ (gtPolyLG[i],gtPolyLG[i+1]) for i in range(0,len(gtPolyLG),2)] ) for gtPolyLG in gtPolygons["Left Grasper"]]) if "Left Grasper" in gtPolygons.keys() else []
        T_Group_gt =  geo.LineString( [point for point in SingleThreadPoints] ) if len(SingleThreadPoints) >1 else []
             
        LG_dl = geo.MultiPolygon([ geo.Polygon(poly) for poly in LgrasperPoints])
        RG_dl =  geo.MultiPolygon([ geo.Polygon(poly) for poly in RgrasperPoints])        
        threadPolys = []
        
        for k in range(len(ThreadContours)):     
            if(len(ThreadContours[k])>2):           
                cnt = ThreadContours[k]
                threadPolys.append( geo.Polygon( [(c[0][0],c[0][1]) for c in cnt]))
        print("threadPolys",len(threadPolys))  
        T_dl =   geo.MultiPolygon( threadPolys )
        pred = [LG_dl,RG_dl,T_dl]
        gt = [LG_Group_gt,RG_Group_gt,T_Group_gt]
        return pred, gt

    
    
    def GetCommonShapes(self,gtPolygons,gtKeypoints,SingleThreadPoints,polylineSeries,ThreadContours,LgrasperPoints,RgrasperPoints):
        RG_Group_gt = geo.MultiPolygon([ geo.Polygon( [ (poly[i],poly[i+1]) for i in range(0,len(poly),2)] ) for poly in gtPolygons["Right Grasper"]]) if "Right Grasper" in gtPolygons.keys() else []
        LG_Group_gt = geo.MultiPolygon([ geo.Polygon( [ (poly[i],poly[i+1]) for i in range(0,len(poly),2)] ) for poly in gtPolygons["Left Grasper"]]) if "Left Grasper" in gtPolygons.keys() else []                
               
        polys = []
        for i in range(len(polylineSeries)):
            l = len(polylineSeries)
            SingleThreadX = []
            SingleThreadY = []
            points = []
            for j in range(0,len(polylineSeries[i]),2):
                SingleThreadX.append(polylineSeries[i][j])
                SingleThreadY.append(polylineSeries[i][j+1])
                points.append((polylineSeries[i][j],polylineSeries[i][j+1]))
            if (len(points)>=3):
                currPoly = geo.Polygon(geo.LineString( [point for point in points] ) )
                polys.append(currPoly)

        #SingleThreadPoints = [(SingleThreadX[i],SingleThreadY[i]) for i in range(len(SingleThreadX))]

        T_Group_gt =  geo.MultiPolygon(polys)  

        for poly in LgrasperPoints:
            if(len(poly)<3):
                LgrasperPoints.remove(poly)
        LG_dl = geo.MultiPolygon([ geo.Polygon(poly) for poly in LgrasperPoints])
        
        for poly in RgrasperPoints:
            if(len(poly)<3):
                RgrasperPoints.remove(poly)
        RG_dl =  geo.MultiPolygon([ geo.Polygon(poly) for poly in RgrasperPoints])
            
        threadPolys = []        
        for k in range(len(ThreadContours)):     
            if(len(ThreadContours[k])>2):           
                cnt = ThreadContours[k]
                threadPolys.append( geo.Polygon( [(c[0][0],c[0][1]) for c in cnt]))
        T_dl =   geo.MultiPolygon(threadPolys)

        #print("\t Original Types", LG_dl.geom_type,RG_dl.geom_type,T_dl.geom_type)
        #pred = [make_valid(LG_dl),make_valid(RG_dl),make_valid(T_dl)]
        pred = [LG_dl,RG_dl,T_dl]
        #print("\t      New Types",pred[0].geom_type,pred[1].geom_type,pred[2].geom_type)

        #for p in pred: print( p.type, end=" ")
        gt = [LG_Group_gt,RG_Group_gt,T_Group_gt]

        return pred, gt


    def GetRingShapes(self,Ring4Points,Ring5Points,Ring6Points,Ring7Points,gtPolygons):
        #print(Ring4Points)
        R4_Group = geo.MultiPolygon([ geo.Polygon( ring ) for ring in Ring4Points if len(ring)> 3]) if  len(Ring4Points)>0 else []
        R5_Group = geo.MultiPolygon([ geo.Polygon( ring ) for ring in Ring5Points if len(ring)> 3]) if  len(Ring5Points)>0 else []
        R6_Group = geo.MultiPolygon([ geo.Polygon( ring ) for ring in Ring6Points if len(ring)> 3]) if  len(Ring6Points)>0 else []
        R7_Group = geo.MultiPolygon([ geo.Polygon( ring ) for ring in Ring7Points if len(ring)> 3]) if  len(Ring7Points)>0 else []

        R4_Group_gt = geo.MultiPolygon([ geo.Polygon( [ (poly[i],poly[i+1]) for i in range(0,len(poly),2)] ) for poly in gtPolygons["Ring_4"]]) if "Ring_4" in gtPolygons.keys() else []
        R5_Group_gt = geo.MultiPolygon([ geo.Polygon( [ (poly[i],poly[i+1]) for i in range(0,len(poly),2)] ) for poly in gtPolygons["Ring_5"]]) if "Ring_5" in gtPolygons.keys() else []
        R6_Group_gt = geo.MultiPolygon([ geo.Polygon( [ (poly[i],poly[i+1]) for i in range(0,len(poly),2)] ) for poly in gtPolygons["Ring_6"]]) if "Ring_6" in gtPolygons.keys() else []
        R7_Group_gt = geo.MultiPolygon([ geo.Polygon( [ (poly[i],poly[i+1]) for i in range(0,len(poly),2)] ) for poly in gtPolygons["Ring_7"]]) if "Ring_7" in gtPolygons.keys() else []
        
        return [R4_Group,R5_Group,R6_Group,R7_Group],[R4_Group_gt,R5_Group_gt,R6_Group_gt,R7_Group_gt]

    def GetNeedleShapes(self,NeedlePoints,gtPolygons):
        if len(NeedlePoints)>0:
            N_dl =  geo.MultiPolygon([ geo.Polygon(poly) for poly in NeedlePoints if len(poly)> 3 ])
            #N_dl = make_valid(N_dl)
        else:
            #print("===> No needle points")
            N_dl = []
        #print(len(NeedlePoints))
        Ring_Group_gt = geo.MultiPolygon([ geo.Polygon( [ (poly[i],poly[i+1]) for i in range(0,len(poly),2)] ) for poly in gtPolygons["Needle Mask"]]) if "Needle Mask" in gtPolygons.keys() else []
        
        return N_dl,Ring_Group_gt
